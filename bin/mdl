#!/bin/env python

# TODO: Check if song already exists in music folder.
# TODO: Add documentation (to `../readme.md`).
# TODO: List all dependencies (as a part of documentation).
# TODO: Option to not sort playlists.
# TODO: Append '/' to a directory variable if not at end?

import os
import signal
import sys

from subprocess import call, check_output
from shutil import copyfile

dirs_from_home_dir = True

dl_dir = '/dl/music/'
editor = os.getenv('EDITOR', 'vim')
lock_fname = 'lock'
mpd_pid_file = '/.config/mpd/pid'
music_dir = '/music/'
playlist_dir = '/.config/mpd/playlists/'
playlist_ext = 'm3u'
snd_urls_fname = 'yourls'
snd_trims_fname = 'trims-pending'
songs_fname = 'songs'
status_fname = 'status'
trims_fname = 'trims'
urls_fname = 'urls'

if dirs_from_home_dir:
    home = os.getenv('HOME')

    dl_dir = home + dl_dir
    mpd_pid_file = home + mpd_pid_file
    music_dir = home + music_dir
    playlist_dir = home + playlist_dir

lockfile = dl_dir + lock_fname
snd_urls_file = dl_dir + snd_urls_fname
snd_trims_file = dl_dir + snd_trims_fname
songs = dl_dir + songs_fname
status_file = dl_dir + status_fname
trims = dl_dir + trims_fname
urls = dl_dir + urls_fname

class cd:
    def __init__(self, new_path):
        self.new_path = os.path.expanduser(new_path)

    def __enter__(self):
        self.saved_path = os.getcwd()
        os.chdir(self.new_path)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.saved_path)

def signal_handler(signal, frame):
    os.remove(lockfile)
    sys.exit(0)

def bell():
    # Send 'bell' signal to terminal.
    call(['echo', '-e', '\"\\a\"'])

def get_title(url):
    return (check_output(['youtube-dl', '--get-title', url])
            .decode('utf-8')
            .rstrip('\n'))

def create_file_ifn(f):
    if not os.path.isfile(f):
        call(['touch', f])

def loc(f):
    return sum(1 for l in open(f))

def dl_ready(f, g):
    nf = loc(f)
    ng = loc(g)

    if nf == ng and nf > 0:
        return True
    else:
        return False

def empty_file(f):
    return os.path.getsize(f) == 0

def gnu_sort(f):
    call(['sort', f, '-o', f])

def process_songs(sl):
    pls2sort = []

    def a2pl(playlist, song, pldir, plext):
        plfile = pldir + playlist + '.' + plext

        create_file_ifn(plfile)
        pls2sort.append(playlist)

        with open(plfile, 'a') as f:
            f.write(song + '.ogg' + '\n')

    def convert_song(name, start, end):
        if start == False and end == False:
            # No trimming.

            call([
                'ffmpeg',
                '-y',
                '-i',
                name + '.webm',
                '-vn',
                '-acodec',
                'copy',
                name + '.ogg',
            ])

        elif start != False and end != False:
            # Trim beginning and end.

            call([
                'ffmpeg',
                '-y',
                '-i',
                name + '.webm',
                '-ss',
                '00:' + start,
                '-to',
                '00:' + end,
                '-vn',
                '-acodec',
                'copy',
                name + '.ogg',
            ])

        elif start == False:
            # Trim only end.

            call([
                'ffmpeg',
                '-y',
                '-i',
                name + '.webm',
                '-to',
                '00:' + end,
                '-vn',
                '-acodec',
                'copy',
                name + '.ogg',
            ])

        else:
            # Trim only beginning.

            call([
                'ffmpeg',
                '-y',
                '-i',
                name + '.webm',
                '-ss',
                '00:' + start,
                '-vn',
                '-acodec',
                'copy',
                name + '.ogg',
            ])

    def post_process_song(name, tags):
        call([
            'lltag',
            '--format',
            '%a - %t',
            '--yes',
            name + '.ogg',
        ])

        a2pl('all', name, playlist_dir, playlist_ext)

        for tag in tags:
            a2pl(tag, name, playlist_dir, playlist_ext)

        call([
            'mv',
            '-v',
            name + '.ogg',
            music_dir
        ])

        call([
            'rm',
            '-v',
            name + '.webm'
        ])

        with open(status_file, 'a') as f:
            f.write(name + '\n')

    for song in sl:
        call([
            'youtube-dl',
            '-f',
            '43',
            '--no-part',
            '-o',
            song['title'] + '.webm',
            song['url']
        ])

        if song['trim']:
            bell()
            trim_okay = False

            if '-' in song['trim']:
                trim_times = song['trim'].split('-')

                if trim_times[0]:
                    trim_case = 'both'
                    convert_song(song['title'], trim_times[0], trim_times[1])

                else:
                    trim_case = 'end'
                    convert_song(song['title'], False, trim_times[1])

            else:
                trim_case = 'start'
                convert_song(song['title'], song['trim'], False)

            while trim_okay == False:
                print('Playing song \'' + song['title'] + '\'')

                call([
                    'mpv',
                    '--loop=inf',
                    song['title'] + '.ogg'
                ])

                okay = input('Is it good? (y/N)')

                if okay == 'y':
                    trim_okay = True

                else:
                    if trim_case == 'both':
                        start_at = ''
                        end_at = ''

                        while start_at == '' and end_at == '':
                            start_at = input('Start at? > ')
                            end_at = input('End at? > ')

                        convert_song(song['title'], start_at, end_at)

                    elif trim_case == 'end':
                        end_at = ''

                        while end_at == '':
                            end_at = input('End at? > ')

                        convert_song(song['title'], False, end_at)

                    else:
                        start_at = ''

                        while start_at == '':
                            start_at = input('Start at? > ')

                        convert_song(song['title'], start_at, False)

            post_process_song(song['title'], song['tags'])

        else:
            convert_song(song['title'], False, False)
            post_process_song(song['title'], song['tags'])

    for pl in pls2sort:
        gnu_sort(playlist_dir + pl + '.' + playlist_ext)

def dl(songs, urls, wdir):
    song_l = []

    with cd(wdir):
        with open(songs) as songs_f, open(urls) as urls_f, open(trims) as trims_f:
            for song, url, trim in zip(songs_f, urls_f, trims_f):
                song = song.rstrip('\n')
                url = url.rstrip('\n')
                trim = trim.rstrip('\n')
                title = None

                # `tags` actually just means which playlists this song belongs
                # to.

                tags = None

                if '/' in song:
                    info = song.split('/')
                    title = info[0]
                    tags = list(filter(None, info[1:]))

                else:
                    title = song
                    tags = []

                song_l.append({
                    'tags': tags,
                    'title': song,
                    'trim': trim,
                    'url': url
                })

        process_songs(song_l)

def append_titles(orig, dest):
    titles = []

    with open(orig) as f:
        for i in range(loc(dest)):
            f.next()

        for line in f:
            line = line.rstrip('\n')
            titles.append(get_title(line))

    for title in titles:
        with open(dest, 'a') as f:
            f.write(title + '\n')

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

if os.path.isfile(lockfile):
    call([editor, snd_urls_file, snd_trims_file])
    sys.exit(0)

create_file_ifn(lockfile)
create_file_ifn(snd_urls_file)
create_file_ifn(snd_trims_file)
create_file_ifn(songs)
create_file_ifn(status_file)
create_file_ifn(trims)
create_file_ifn(urls)

while True:
    if dl_ready(songs, urls):
        dl(songs, urls, dl_dir)
        break

    elif empty_file(songs) and empty_file(urls):
        def copy_non_empty_file(source, dest):
            if not empty_file(source):
                copyfile(source, dest)
                open(source, 'w').close()

        copy_non_empty_file(snd_urls_file, urls)
        copy_non_empty_file(snd_trims_file, trims)

        call([editor, urls, trims, songs])

        if empty_file(songs) and empty_file(urls):
            print('Nothing inputted! Aborting.')
            sys.exit(0)

    elif loc(songs) > loc(urls):
        print('Songs is longer than urls! Aborting.')
        sys.exit(0)

    else:
        append_titles(urls, songs)
        bell()
        call([editor, songs, trims, urls])

if os.path.isfile(mpd_pid_file) and not empty_file(mpd_pid_file):
    call(['mpc', 'update'])

open(songs, 'w').close()
open(status_file, 'w').close()
open(trims, 'w').close()
open(urls, 'w').close()
os.remove(lockfile)
bell()
